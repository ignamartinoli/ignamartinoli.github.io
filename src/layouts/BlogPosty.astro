---
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import Background from "../components/Background.astro";
import BaseHead from '../components/BaseHead.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';

type Props = CollectionEntry<'blog'>['data'];
const { title, description, pubDate, updatedDate, heroImage } = Astro.props;
---

<html lang="en">
  <head>
    <BaseHead title={title} description={description} />
    <style>
      main {
        width: calc(100% - 2em);
        max-width: 1200px;
        margin: 0 auto;
      }

      .post-layout {
        display: grid;
        grid-template-columns: 1fr minmax(220px, 280px);
        gap: 2rem;
        align-items: start;
      }

      article {
        min-width: 0; /* allow text to shrink in grid */
      }

      .hero-image {
        width: 100%;
      }
      .hero-image img {
        display: block;
        margin: 0 auto;
        border-radius: 12px;
        box-shadow: var(--box-shadow);
      }

      .prose {
        width: 720px;
        max-width: 100%;
        margin: auto;
        padding: 1em;
        color: rgb(var(--text));
      }

      .title {
        margin-bottom: 1em;
        padding: 1em 0;
        text-align: center;
        line-height: 1;
      }
      .title h1 { margin: 0 0 0.5em 0; }

      .date { margin-bottom: 0.5em; color: rgb(var(--gray)); }
      .last-updated-on { font-style: italic; }

      aside.toc {
        position: sticky;
        top: 6rem; /* below header */
        height: max-content;
        padding: 1rem;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,.5);
        background: color-mix(in srgb, var(--overlay2) 5%, transparent);
        backdrop-filter: blur(10px);
      }
      .toc h2 {
        margin: 0 0 .5rem 0;
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: .06em;
        color: rgb(var(--gray));
      }

      .toc ul {
        list-style: none;
        margin: 0;
        padding-left: 0;
      }

      .toc li { margin: .25rem 0; }
      .toc a {
        text-decoration: none;
        color: inherit;
        opacity: .85;
      }
      .toc a:hover { opacity: 1; }

      /* Indentation by heading level */
      .toc li[data-depth="3"] { padding-left: 1rem; }
      .toc li[data-depth="4"] { padding-left: 2rem; }

      /* Active link made bold */
      .toc a.is-active { font-weight: 700; opacity: 1; }

      @media (max-width: 1024px) {
        .post-layout {
          grid-template-columns: 1fr;
        }
        aside.toc {
          order: -1; /* show ToC above article on mobile */
          top: 0;
          margin-bottom: 1rem;
        }
      }
    </style>
  </head>

  <body>
    <Background />
    <Header />

    <main class="post-layout">
      <article>
        <div class="hero-image">
          {heroImage && <Image width={1020} height={510} src={heroImage} alt="" />}
        </div>

        <div class="prose" id="post-prose">
          <div class="title">
            <div class="date">
              <FormattedDate date={pubDate} />
              {
                updatedDate && (
                  <div class="last-updated-on">
                    Last updated on <FormattedDate date={updatedDate} />
                  </div>
                )
              }
            </div>
            <h1>{title}</h1>
            <hr />
          </div>

          <!-- The markdown content (includes [toc] which we’ll relocate) -->
          <slot />
        </div>
      </article>

      <!-- Sidebar: we’ll move the remark-toc list here -->
      <aside class="toc" id="toc">
        <h2>Table of contents</h2>
        <div id="toc-body"><!-- gets filled on load --></div>
      </aside>
    </main>

    <script type="module">
      // --- 1) Find the remark-toc list inside the article and move it to the sidebar ---
      const prose = document.getElementById('post-prose');
      const tocBody = document.getElementById('toc-body');

      // remark-toc usually emits: <h2>Table of contents</h2><ul>...</ul>
      // We’ll look for that heading then grab the following <ul>.
      const tocHeading = Array.from(prose.querySelectorAll('h1,h2,h3,h4,h5,h6'))
        .find(h => h.textContent.trim().toLowerCase() === 'table of contents');

      if (tocHeading) {
        const maybeList = tocHeading.nextElementSibling;
        if (maybeList && maybeList.tagName === 'UL') {
          // Mark li depth by matching number of hashes in href target heading
          Array.from(maybeList.querySelectorAll('li')).forEach(li => {
            const a = li.querySelector('a');
            if (!a) return;
            // depth heuristic: inspect the target heading level
            const id = a.getAttribute('href')?.replace('#', '');
            const target = id ? prose.querySelector(`[id="${CSS.escape(id)}"]`) : null;
            const depth = target ? Number((target.tagName.match(/^H([1-6])$/) || [,'2'])[1]) : 2;
            li.setAttribute('data-depth', String(depth));
          });

          tocBody.appendChild(maybeList);
          // Remove the in-flow heading + (now moved) list from the article
          tocHeading.remove();
        }
      }

      // --- 2) Highlight active section in the TOC as you scroll ---
      const headings = Array.from(prose.querySelectorAll('h2, h3, h4')); // tweak if you want more/less depth
      const tocLinks = new Map(); // id -> <a>
      tocBody.querySelectorAll('a[href^="#"]').forEach(a => {
        const id = a.getAttribute('href').slice(1);
        tocLinks.set(id, a);
      });

      const setActive = (id) => {
        tocLinks.forEach(a => a.classList.remove('is-active'));
        const a = tocLinks.get(id);
        if (a) a.classList.add('is-active');
      };

      let currentId = null;
      const observer = new IntersectionObserver((entries) => {
        // Pick the topmost visible heading
        const visible = entries
          .filter(e => e.isIntersecting)
          .sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top);

        if (visible[0]) {
          const id = visible[0].target.id;
          if (id && id !== currentId) {
            currentId = id;
            setActive(id);
          }
        } else {
          // If none intersecting (e.g. between sections), pick the last heading above viewport
          let best = null;
          for (const h of headings) {
            const rect = h.getBoundingClientRect();
            if (rect.top <= 96 /* header offset */) best = h;
            else break;
          }
          if (best && best.id !== currentId) {
            currentId = best.id;
            setActive(best.id);
          }
        }
      }, {
        rootMargin: '-96px 0px -60% 0px', // trigger a little before/after
        threshold: [0, 1.0],
      });

      headings.forEach(h => {
        if (!h.id) {
          // rehype-slug should have set ids, but just in case
          h.id = h.textContent.toLowerCase().replace(/[^\w]+/g, '-');
        }
        observer.observe(h);
      });

      // Optional: click scroll offset if you have a fixed header
      tocBody.addEventListener('click', (e) => {
        const a = e.target.closest('a[href^="#"]');
        if (!a) return;
        const id = a.getAttribute('href').slice(1);
        const el = document.getElementById(id);
        if (!el) return;
        e.preventDefault();
        const top = el.getBoundingClientRect().top + window.scrollY - 80; // header offset
        window.scrollTo({ top, behavior: 'smooth' });
        history.replaceState(null, '', `#${id}`);
      });
    </script>
  </body>
</html>
